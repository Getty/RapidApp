package RapidApp::ModuleDispatcher;

use Moose;
use RapidApp::Include 'perlutil';

our $VERSION = '0.1';

has 'exceptionStore'        => ( is => 'rw' ); # either an exceptionStore instance, or the name of a Model implementing one
has 'saveErrors'            => ( is => 'rw', isa => 'Bool', default => 0 );
has 'recordUserErrors'      => ( is => 'rw', isa => 'Bool', default => 1 );
has 'reportIdForUserErrors' => ( is => 'rw', isa => 'Bool', default => 0 );

sub BUILD {}


has 'dispatchTarget' => ( is => 'rw', isa => 'Str',  default => "/");

=head2 $ctlr->dispatch( $c, @args )

dispatch takes a 

It also is responsible for cleaning temporary values from the Modules after the request is over.

=cut
sub dispatch {
	my ($self, $c, @args)= @_;
	
	# put the debug flag into the stash, for easy access in templates
	$c->stash->{debug} = $c->debug;
	
	# provide hints for our controllers on what contect type is expected
	$c->stash->{requestContentType}=
		$c->req->header('X-RapidApp-RequestContentType')
		|| $c->req->param('RequestContentType')
		|| '';
	
	# special die handler to make sure we don't throw plain strings.
	local $SIG{__DIE__}= \&RapidApp::Error::dieConverter;
	my $targetModule;
	try {
		# get the root module (or sub-module, if we've been configured that way)
		$targetModule= $c->rapidApp->module($self->dispatchTarget)
		
		# now run the controller
		RapidApp::ScopedGlobals->applyForSub(
			{ catalystInstance => $c, log => $c->log, },
			sub { $result = $targetModule->Controller($c, @args); }
		);
		
		$c->stash->{controllerResult} = $result;
		
		# clear out any temporarily cached attributes generated by this request
		$targetModule->recursive_clear_per_request_vars;
	}
	catch {
		$result= $self->onException(RapidApp::Error::capture($_));
		
		# redundant, but we need to make sure it happens if the request dies
		# we want to leave the other one in the try block so we can catch errors conveniently
		$targetModule->recursive_clear_per_request_vars if defined $targetModule;
	};
	
	# if the body was not set, make sure a view was chosen
	defined $c->res->body || defined $c->stash->{current_view} || defined defined $self->c->stash->{current_view_instance}
		or die "No view was selected, and a body was not generated";
	
	return $result;
}

=head2 onException( RapidApp::Error )

This is called whenever an exception is thrown from the chain of Controller calls.

Default behavior for this routine is to log the exception, dump its debugging info if present,
and render it as either a RapidApp exception (for JSON requests) or as a HTTP-500.

=cut
sub onException {
	my ($self, $err)= @_;
	
	my $c= $self->c;
	my $log= $c->log;
	$c->stash->{exception}= $err;
	$c->stash->{isUserError}= $err->isUserError;
	
	if ($isUserError)  {
		$log->info("User usage error: ".$err->userMessage);
	}
	else {
		$log->error("RapidApp Exception: ".$msg);
	}
	
	# XXX integrate this
	if (defined $refId && ($self->reportIdForUserErrors || !$isUserErr)) {
		$c->stash->{exceptionRefId}= $refId;
	}
	
	# on exceptions, we either generate a 503, or a JSON response to the same effect
	if ($c->stash->{requestContentType} eq 'JSON') {
		$c->stash->{current_view}= 'RapidApp::JSON';
	}
	elsif ($isUserError) {
		# TODO: change this to an actual view
		length($c->response->body) > 0
			or $c->response->body("Error : " . $err->userMessage);
	}
	else {
		$c->stash->{current_view}= 'RapidApp::HttpStatus';
		$c->res->status(500);
	}
}

# backward-compatibility shim
# I decided "viewport" was a more appropriate name, and that is the name of the TT file anyway.  -MLC
sub viewpanel {
	return (shift)->viewport;
}

# build a HTML viewport for the ExtJS content
# we override the config_url and the title
after 'viewport' => sub {
	my $self= shift;
	$self->c->stash->{config_url} = $self->base_url . '/' . $self->default_module;
	$self->c->stash->{title} = $self->app_title;
};


1;
