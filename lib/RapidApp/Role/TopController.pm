package RapidApp::Role::TopController;

use strict;
use warnings;
use Moose::Role;
with 'RapidApp::Role::Controller';

use RapidApp::ScopedGlobals;
use Try::Tiny;
use Storable;

our $VERSION = '0.1';

#### --------------------- ####


has 'app_title' 						=> ( is => 'ro',	default => 'RapidApp Application'		);

sub BUILD {}

=head2 after BUILD

TopController enables the auto_viewport capability of Controller by default.

=cut
after 'BUILD' => sub {
	my $self= shift;
	$self->auto_viewport(1);
};

=head2 around Controller

TopController wraps the Controller method to special setup and exception handling.

It also is responsible for cleaning temporary values from the Modules after the request is over.

=cut
around 'Controller' => sub {
	my $orig = shift;
	my $self = shift;
	my ( $c, @args ) = @_;
	
	# mask the globals with the values for this request
	local $RapidApp::ScopedGlobals::CatalystInstance= $c;
	local $RapidApp::ScopedGlobals::Log= $c->log;
	
	my $result;
	
	# put the debug flag into the stash, for easy access in templates
	$c->stash->{debug} = $c->debug;
	
	try {
		# special die handler to make sure we don't throw plain strings.
		local $SIG{__DIE__}= \&RapidApp::Error::dieConverter;
		# provide hints for our controllers on what contect type is expected
		$c->stash->{requestContentType}=
			$c->req->header('X-RapidApp-RequestContentType')
			|| $c->req->param('RequestContentType')
			|| '';
		
		# now run the controller
		$c->stash->{controllerResult} = $result = $self->$orig($c, @args);
	}
	catch {
		my $errFields= $self->extractFieldsFromException($_);
		$result= $self->onException($errFields);
	};
	
	# clear out any temporarily cached attributes generated by this request
	$self->recursive_clear_per_request_vars;
	
	# if the body was not set, make sure a view was chosen
	defined $c->res->body || defined $c->stash->{current_view} || defined defined $self->c->stash->{current_view_instance}
		or die "No view was selected, and a body was not generated";
	
	return $result;
};

=head2 extractFieldsFromException( $err )

Attempt to pull useful fields form an exception.  This gives slightly more useful parameters to ->onException.

=cut
sub extractFieldsFromException {
	my ($self, $err)= @_;
	
	my ($msg, $srcLoc);
	my $isUserError= 0;
	
	if (ref $err) {
		$err->can('message') and $msg= $err->message;
		$msg ||= $err->{message};
		
		$err->can('file') and $srcLoc= $err->file . ($err->can('line')? ' line ' . $err->line : '');
		$srcLoc ||= $err->{file};
		$srcLoc =~ s|.*?/lib/||;
		
		$isUserError= $err->can('userMessage') && length ($err->userMessage);
	}
	$msg ||= ''.$err;
	chomp($msg);
	
	if ($msg =~ /^(.*?) at ([^ ]+.p[ml](?: line [0-9]+)?).*/) {
		$msg= $1;
		$srcLoc= $2;
		$srcLoc =~ s|.*?/lib/||;
	}
	
	return { err => $err, msg => $msg, srcLoc => $srcLoc, isUserError => $isUserError };
}

=head2 onException( { err => $exeptionObject, msg => $textOfError, srcLoc => $fileAndLine } )

This is called whenever an exception is thrown from the chain of Controller calls.

Default behavior for this routine is to log the exception, dump its debugging info if present,
and render it as either a RapidApp exception (for JSON requests) or as a HTTP-500.

=cut
sub onException {
	my $self= shift;
	my $params= ref $_[0]? $_[0] : { @_ };
	my $err= $params->{err};
	my $msg= $params->{msg};
	my $srcLoc= $params->{srcLoc};
	my $isUserError= $params->{isUserError};
	
	my $c= $self->c;
	my $log= $c->log;
	$c->stash->{exception}= $err;
	$c->stash->{isUserError}= $isUserError;
	
	if ($isUserError)  {
		$log->info("User usage error: ".$err->userMessage);
	}
	else {
		$log->error("RapidApp Exception: ".$msg);
	}
	
	# on exceptions, we either generate a 503, or a JSON response to the same effect
	if ($c->stash->{requestContentType} eq 'JSON') {
		$c->stash->{current_view}= 'RapidApp::JSON';
	}
	elsif ($isUserError) {
		# TODO: change this to an actual view
		length($c->response->body) > 0
			or $c->response->body("Error : " . $err->userMessage);
	}
	else {
		$c->stash->{current_view}= 'RapidApp::HttpStatus';
		$c->res->status(500);
	}
}

# backward-compatibility shim
# I decided "viewport" was a more appropriate name, and that is the name of the TT file anyway.  -MLC
sub viewpanel {
	return (shift)->viewport;
}

# build a HTML viewport for the ExtJS content
# we override the config_url and the title
after 'viewport' => sub {
	my $self= shift;
	$self->c->stash->{config_url} = $self->base_url . '/' . $self->default_module;
	$self->c->stash->{title} = $self->app_title;
};


1;
