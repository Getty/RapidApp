package RapidApp::DBIC::ImportEngine;
use Moose;

use Params::Validate ':all';
use IO::Handle;
use RapidApp::Debug 'DEBUG';
use RapidApp::JSON::MixedEncoder 'decode_json', 'encode_json';

has 'schema' => ( is => 'ro', isa => 'DBIx::Class::Schema', required => 1 );

with 'RapidApp::DBIC::SchemaAnalysis';

# map of {ColKey}{read_id} => $saved_id
has 'auto_id_map' => ( is => 'ro', isa => 'HashRef[HashRef[Str]]', default => sub {{}} );

# map of {srcN}{primary_key} => \@unfinished_records
has 'pending_records' => ( is => 'rw', isa => 'HashRef[HashRef[ArrayRef]]', default => sub {{}} );

# map of {srcN}{primary_key} => 1
has 'processed' => ( is => 'ro', isa => 'HashRef[HashRef]', default => sub {{}} );

sub import_records {
	my ($self, $src)= @_;
	my $data;
	$self->schema->txn_do( sub {
		while (($data= $self->read_record($src))) {
			$self->import_record($data);
		}
		if (scalar keys %{$self->pending_records}) {
			my $cnt= 0;
			map { map { $cnt+= scalar @$_ } values %$_ } values %{$self->pending_records};
			if ($cnt > 0) {
				$self->report_missing_keys ;
				die "$cnt records could not be added due to missing dependencies\nSee /tmp/rapidapp_import_errors.txt for details\n";
			}
		}
	});
}

sub report_missing_keys {
	my $self= shift;
	
	my $debug_fd= IO::File->new;
	$debug_fd->open('/tmp/rapidapp_import_errors.txt', 'w') or die $!;
	my $cnt= 0;
	for my $srcN (keys %{$self->pending_records}) {
		while (my ($pk, $recs)= each %{$self->pending_records->{$srcN}}) {
			$debug_fd->print("Required $srcN = $pk\n");
			$debug_fd->print("\t".encode_json($_)."\n") for (@$recs);
			$cnt+= scalar @$recs;
		}
	}
	$debug_fd->print("\nFound keys:\n");
	for my $srcN (keys %{$self->processed}) {
		$debug_fd->print("\t".$srcN."\t".$_."\n") for %{$self->processed->{$srcN}};
	}
	$debug_fd->close();
}

sub read_record {
	my ($self, $src)= @_;
	my $line= $src->getline;
	defined($line) or return undef;
	chomp $line;
	return decode_json($line);
}

sub import_record {
	my $self= shift;
	my %p= validate(@_, { source => {type=>SCALAR}, data => {type=>HASHREF} });
	my $srcN= $p{source};
	my $rec= $p{data};
	defined $self->valid_sources->{$srcN} or die "Cannot import records into source $srcN";
	my $rs= $self->schema->resultset($srcN);
	my $resultClass= $rs->result_class;
	my $code;
	
	# first, handle potential import munging
	if ($code= $resultClass->can('import_create_munge')) {
		$rec= $resultClass->$code($rec);
	}
	
	# then calculate dependencies on other rows
	my @deps= ($code= $resultClass->can('calculate_record_dependencies'))?
		$resultClass->$code($rec) : $self->calculate_dependencies($srcN, $rec);
	
	$self->perform_insert($srcN, $rec) if ($self->process_dependencies($srcN, $rec, \@deps));
}

sub get_primary_key_string {
	my ($self, $rsrc, $rec)= @_;
	my @pkvals;
	for my $colN ($rsrc->primary_columns) {
		defined $rec->{$colN} or return '';  # primary key wasn't given.  Hopefully it gets autogenerated during insert.
		push @pkvals, $rec->{$colN};
	}
	return stringify_pk(@pkvals);
}

sub stringify_pk {
	join '', map { length($_).'|'.$_ } @_;
}

sub perform_insert {
	my ($self, $srcN, $rec)= @_;
	DEBUG('export', 'perform_insert', $srcN, $rec);
	
	my $rs= $self->schema->resultset($srcN);
	my $resultClass= $rs->result_class;
	my ($code, $row, $pkstr);
	
	# calculate the primary key of this row
	if ($pkstr= $self->get_primary_key_string($rs->result_source, $rec)) {
		# mark it as seen, if the primary key is known at this point
		($self->processed->{$srcN} ||= {})->{$pkstr}= 1;
	}
	
	my @oldIds;
	# there should just be zero or one, but we might extend this to auto-datetimes too
	my @autoIdCols= @{$self->auto_id_columns_per_source->{$srcN} || []};
	for my $colN (@autoIdCols) {
		push @oldIds, delete $rec->{$colN};
	}
	
	# perform the insert, possibly calling the Result class to do the work
	if ($code= $resultClass->can('import_create')) {
		$row= $resultClass->$code($rs, $rec);
	}
	else {
		$row= $rs->create($rec);
	}
	
	# record any auto-id values that got generated
	for my $colN (@autoIdCols) {
		my $origVal= pop @oldIds;
		my $newVal= $row->get_column($colN);
		DEBUG('export', origVal => $origVal, newVal => $newVal, srcN => $srcN, colN => $colN);
		($self->auto_id_map->{$srcN.'.'.$colN} ||= {})->{ $origVal }= $newVal;
	}
	
	# now, insert any records that depended on this one (unless they have other un-met deps, in which case they get re-queued)
	if ($pkstr && $self->pending_records->{$srcN}) {
		if (my $pending= delete $self->pending_records->{$srcN}{$pkstr}) {
			for my $p (@$pending) {
				$self->perform_insert(@$p) if ($self->process_dependencies(@$p));
			}
		}
	}
}

sub calculate_dependencies {
	my ($self, $srcN, $rec)= @_;
	my @deps;
	
	# for each field that needs remapped,  create a dependency that says this record depends on some primary-key of some source
	# (we assume it is an auto-id column, since this is all we support now)
	for my $colN (@{$self->remap_fields_per_source->{$srcN}}) {
		if (defined $rec->{$colN}) {
			#  find out what Source this value is coming from
			my $srcCol= $self->related_auto_id_columns->{$srcN.'.'.$colN};
			next if $srcCol eq $srcN.'.'.$colN;
			
			my ($peerSrcN)= split /[.]/, $srcCol;
			# all auto-id columns will in fact be the single primary key value
			# (hopefully this is true for all databases...)
			push @deps, { srcN => $peerSrcN, pk => [ $rec->{$colN} ] };
		}
	}
	return @deps;
}

sub process_dependencies {
	my $self= shift;
	my ($srcN, $rec, $deps)= @_;
	
	# first, check to see if any are unresolved, and if so, queue it again and return false
	for my $dep (@$deps) {
		# to handle multiple-column primary keys, we combine the values into a single string
		$dep->{pkstr} ||= stringify_pk(@{$dep->{pk}});
		# if a record in that source by that primary key has not been inserted...
		if (!$self->processed->{$dep->{srcN}}{$dep->{pkstr}}) {
			# then we add this record to a list that will get re-attempted after that primary key gets processed.
			my $pending= ($self->pending_records->{$dep->{srcN}}{$dep->{pkstr}} ||= []);
			push @$pending, [ @_ ];
			return 0;
		}
	}
	
	# if they're all resolved, then swap the values
	for my $colN (@{$self->remap_fields_per_source->{$srcN}}) {
		if (defined $rec->{$colN}) {
			# get the colKey of the table which defines the auto_id column
			my $originatingCol= $self->related_auto_id_columns->{$srcN.'.'.$colN};
			next if $originatingCol eq $srcN.'.'.$colN;
			# get the translated value for our imported value of that column
			my $newVal= $self->auto_id_map->{$originatingCol}->{$rec->{$colN}};
			# swap it
			$rec->{$colN}= $newVal;
		}
	}
	
	# the record will now get inserted
	return 1;
}

no Moose;
__PACKAGE__->meta->make_immutable;
1;